From 4633b3333d5dc31f745e9568fae7fc4e6d4572ae Mon Sep 17 00:00:00 2001
From: hanliyang <hanliyang@hygon.cn>
Date: Thu, 15 Apr 2021 08:32:24 -0400
Subject: [PATCH 28/28] kvm: Add support for CSV2 reboot

Linux will set vcpu.arch.guest_state_protected to true after execute
LAUNCH_UPDATE_VMSA successfully, and then KVM will prevent any changes
to VMCB State Save Area.

In order to support CSV2 guest reboot, calls cpus_control_pre_system_reset()
to set vcpu.arch.guest_state_protected to false, and calls
cpus_control_post_system_reset() to restore VMSA of guest's vcpu with
data generated by LAUNCH_UPDATE_VMSA.

In addition, for memory encrypted guest, additional works may be
required during system reset, such as flushing the cache. The function
cpus_control_post_system_reset() hints linux to flush caches of guest
memory.

Signed-off-by: hanliyang <hanliyang@hygon.cn>
---
 accel/kvm/kvm-accel-ops.c  |  3 +++
 accel/kvm/kvm-all.c        | 10 ++++++++++
 accel/kvm/kvm-cpus.h       |  3 +++
 include/sysemu/accel-ops.h |  3 +++
 include/sysemu/cpus.h      |  2 ++
 linux-headers/linux/kvm.h  |  4 ++++
 system/cpus.c              | 14 ++++++++++++++
 system/runstate.c          |  4 ++++
 8 files changed, 43 insertions(+)

diff --git a/accel/kvm/kvm-accel-ops.c b/accel/kvm/kvm-accel-ops.c
index 6195150a..54f19028 100644
--- a/accel/kvm/kvm-accel-ops.c
+++ b/accel/kvm/kvm-accel-ops.c
@@ -112,6 +112,9 @@ static void kvm_accel_ops_class_init(ObjectClass *oc, void *data)
     ops->remove_breakpoint = kvm_remove_breakpoint;
     ops->remove_all_breakpoints = kvm_remove_all_breakpoints;
 #endif
+
+    ops->control_pre_system_reset = kvm_cpus_control_pre_system_reset;
+    ops->control_post_system_reset = kvm_cpus_control_post_system_reset;
 }
 
 static const TypeInfo kvm_accel_ops_type = {
diff --git a/accel/kvm/kvm-all.c b/accel/kvm/kvm-all.c
index e39a810a..e5ed69c3 100644
--- a/accel/kvm/kvm-all.c
+++ b/accel/kvm/kvm-all.c
@@ -2761,6 +2761,16 @@ void kvm_cpu_synchronize_pre_loadvm(CPUState *cpu)
     run_on_cpu(cpu, do_kvm_cpu_synchronize_pre_loadvm, RUN_ON_CPU_NULL);
 }
 
+void kvm_cpus_control_pre_system_reset(void)
+{
+    kvm_vm_ioctl(kvm_state, KVM_CONTROL_VCPU_PRE_SYSTEM_RESET, NULL);
+}
+
+void kvm_cpus_control_post_system_reset(void)
+{
+    kvm_vm_ioctl(kvm_state, KVM_CONTROL_VCPU_POST_SYSTEM_RESET, NULL);
+}
+
 #ifdef KVM_HAVE_MCE_INJECTION
 static __thread void *pending_sigbus_addr;
 static __thread int pending_sigbus_code;
diff --git a/accel/kvm/kvm-cpus.h b/accel/kvm/kvm-cpus.h
index ca40add3..27b9d0d9 100644
--- a/accel/kvm/kvm-cpus.h
+++ b/accel/kvm/kvm-cpus.h
@@ -23,4 +23,7 @@ int kvm_insert_breakpoint(CPUState *cpu, int type, vaddr addr, vaddr len);
 int kvm_remove_breakpoint(CPUState *cpu, int type, vaddr addr, vaddr len);
 void kvm_remove_all_breakpoints(CPUState *cpu);
 
+void kvm_cpus_control_pre_system_reset(void);
+void kvm_cpus_control_post_system_reset(void);
+
 #endif /* KVM_CPUS_H */
diff --git a/include/sysemu/accel-ops.h b/include/sysemu/accel-ops.h
index ef91fc28..7a32e7f8 100644
--- a/include/sysemu/accel-ops.h
+++ b/include/sysemu/accel-ops.h
@@ -53,6 +53,9 @@ struct AccelOpsClass {
     int (*insert_breakpoint)(CPUState *cpu, int type, vaddr addr, vaddr len);
     int (*remove_breakpoint)(CPUState *cpu, int type, vaddr addr, vaddr len);
     void (*remove_all_breakpoints)(CPUState *cpu);
+
+    void (*control_pre_system_reset)(void);
+    void (*control_post_system_reset)(void);
 };
 
 #endif /* ACCEL_OPS_H */
diff --git a/include/sysemu/cpus.h b/include/sysemu/cpus.h
index b4a566cf..f24d27da 100644
--- a/include/sysemu/cpus.h
+++ b/include/sysemu/cpus.h
@@ -44,6 +44,8 @@ extern int icount_align_option;
 void qemu_cpu_kick_self(void);
 
 bool cpus_are_resettable(void);
+void cpus_control_pre_system_reset(void);
+void cpus_control_post_system_reset(void);
 
 void cpu_synchronize_all_states(void);
 void cpu_synchronize_all_post_reset(void);
diff --git a/linux-headers/linux/kvm.h b/linux-headers/linux/kvm.h
index 36d6ba82..638befe8 100644
--- a/linux-headers/linux/kvm.h
+++ b/linux-headers/linux/kvm.h
@@ -1572,6 +1572,10 @@ struct kvm_s390_ucas_mapping {
 #define KVM_GET_DEVICE_ATTR	  _IOW(KVMIO,  0xe2, struct kvm_device_attr)
 #define KVM_HAS_DEVICE_ATTR	  _IOW(KVMIO,  0xe3, struct kvm_device_attr)
 
+/* ioctls for control vcpu setup during system reset */
+#define KVM_CONTROL_VCPU_PRE_SYSTEM_RESET  _IO(KVMIO, 0xe8)
+#define KVM_CONTROL_VCPU_POST_SYSTEM_RESET _IO(KVMIO, 0xe9)
+
 /*
  * ioctls for vcpu fds
  */
diff --git a/system/cpus.c b/system/cpus.c
index a444a747..cbeec13f 100644
--- a/system/cpus.c
+++ b/system/cpus.c
@@ -193,6 +193,20 @@ void cpu_synchronize_pre_loadvm(CPUState *cpu)
     }
 }
 
+void cpus_control_pre_system_reset(void)
+{
+    if (cpus_accel->control_pre_system_reset) {
+        cpus_accel->control_pre_system_reset();
+    }
+}
+
+void cpus_control_post_system_reset(void)
+{
+    if (cpus_accel->control_post_system_reset) {
+        cpus_accel->control_post_system_reset();
+    }
+}
+
 bool cpus_are_resettable(void)
 {
     if (cpus_accel->cpus_are_resettable) {
diff --git a/system/runstate.c b/system/runstate.c
index ea9d6c2a..365f2f44 100644
--- a/system/runstate.c
+++ b/system/runstate.c
@@ -486,6 +486,8 @@ void qemu_system_reset(ShutdownCause reason)
 
     mc = current_machine ? MACHINE_GET_CLASS(current_machine) : NULL;
 
+    cpus_control_pre_system_reset();
+
     cpu_synchronize_all_states();
 
     if (mc && mc->reset) {
@@ -502,6 +504,8 @@ void qemu_system_reset(ShutdownCause reason)
         qapi_event_send_reset(shutdown_caused_by_guest(reason), reason);
     }
     cpu_synchronize_all_post_reset();
+
+    cpus_control_post_system_reset();
 }
 
 /*
-- 
2.25.1

